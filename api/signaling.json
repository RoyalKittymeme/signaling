// Servidor de signalización WebSocket para Plethorix-P2P
// Configuración optimizada para Vercel

// Almacenamiento en memoria
const activeConnections = new Map();

function generatePlethorixId() {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let randomId = '';
  for (let i = 0; i < 8; i++) {
    randomId += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return `Plethorix-${randomId}`;
}

// Para Vercel, necesitamos manejar WebSockets de forma diferente
// ya que Vercel Serverless Functions no soporta WebSockets persistentes nativamente

// En su lugar, usaremos un enfoque con Server-Sent Events (SSE) o polling
// Esta es una solución temporal - para WebSockets reales necesitarías un servicio separado

export default async function handler(req, res) {
  // Configurar CORS headers
  res.setHeader('Access-Control-Allow-Credentials', true);
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
  res.setHeader(
    'Access-Control-Allow-Headers',
    'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version'
  );

  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  const { action } = req.query;

  switch (action) {
    case 'register':
      // Registrar nuevo nodo
      const nodeId = generatePlethorixId();
      activeConnections.set(nodeId, {
        id: nodeId,
        lastSeen: Date.now(),
        isBootstrap: false,
        data: req.body || {}
      });

      res.status(200).json({
        type: 'welcome',
        nodeId: nodeId,
        timestamp: Date.now(),
        activeNodes: Array.from(activeConnections.keys()).filter(id => id !== nodeId)
      });
      break;

    case 'get-peers':
      // Obtener lista de pares
      const { nodeId: requestingNodeId } = req.body;
      const peers = Array.from(activeConnections.keys()).filter(id => id !== requestingNodeId);
      
      res.status(200).json({
        type: 'peer-list',
        peers: peers,
        timestamp: Date.now()
      });
      break;

    case 'send-signal':
      // Enviar señal a otro nodo (simulado)
      const { from, to, signal } = req.body;
      
      // En un servidor real, aquí almacenarías la señal para que el destinatario la recoja
      // Esta es una simulación para Vercel Serverless
      
      res.status(200).json({
        type: 'signal-delivered',
        from: from,
        to: to,
        timestamp: Date.now()
      });
      break;

    case 'heartbeat':
      // Mantener nodo activo
      const { nodeId: heartbeatNodeId } = req.body;
      if (activeConnections.has(heartbeatNodeId)) {
        activeConnections.get(heartbeatNodeId).lastSeen = Date.now();
      }
      
      res.status(200).json({
        type: 'heartbeat-ack',
        timestamp: Date.now()
      });
      break;

    default:
      // Información del servidor
      res.status(200).json({
        status: 'plethorix-signaling-server',
        version: '1.0.0',
        activeConnections: activeConnections.size,
        supportedActions: ['register', 'get-peers', 'send-signal', 'heartbeat'],
        message: 'Serverless signaling server for Plethorix-P2P'
      });
  }

  // Limpiar conexiones antiguas (más de 5 minutos)
  const now = Date.now();
  for (const [nodeId, connection] of activeConnections.entries()) {
    if (now - connection.lastSeen > 300000) { // 5 minutos
      activeConnections.delete(nodeId);
    }
  }
}
